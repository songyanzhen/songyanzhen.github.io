<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[React Hooks记录]]></title>
    <url>%2F2020%2F06%2F17%2FReact%20Hooks%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[记录 React Hooks 学习情况，希望能通过记录的方式更深入地了解Hooks相关原理。主要内容来源： https://github.com/dt-fe/weekly/blob/v2/104.%E7%B2%BE%E8%AF%BB%E3%80%8AFunction%20Component%20%E5%85%A5%E9%97%A8%E3%80%8B.md Function Component 就是以 Function 的形式创建的 React 组件，Hooks 是辅助 Function Component 的工具。 1.useState12345678910111213141516171819function Counter() &#123; const [count, setCount] = useState(0); const log = () =&gt; &#123; setCount(count + 1); setTimeout(() =&gt; &#123; console.log(count); &#125;, 3000); &#125;; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;log&#125;&gt;Click me&lt;/button&gt; &lt;/div&gt; );&#125;// 0 1 2 state 是 Immutable 的（不可改变的） Class Component：通过 this.state 读取 state，会导致每次代码执行都会去拿最新的 state 引用 // 3 3 3 Function Component： 通过数组第二个参数 Set 一个新值后，原来的值会形成一个新的引用在下次渲染时。（感觉应该是当前渲染？或者是新的值会形成一个新的引用在下次渲染时？） 由于对 state 的读取没有通过 this.的方式，使得每次 setTimeout 都读取了当时渲染闭包环境的数据，虽然最新的值跟着最新的渲染变了，但旧的渲染里，状态依然是旧值。 共渲染四次（首次渲染+三次 setState，setTimeout 分别生效在 1、2、3 次渲染 → 对应 state 值 0、1、2） 2.useRef12345678910111213141516171819function Counter() &#123; const count = useRef(0); const log = () =&gt; &#123; count.current++; setTimeout(() =&gt; &#123; console.log(count.current); &#125;, 3000); &#125;; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count.current&#125; times&lt;/p&gt; &lt;button onClick=&#123;log&#125;&gt;Click me&lt;/button&gt; &lt;/div&gt; );&#125;// 3 3 3 通过 useRef 创建的对象，其值只有一份，而且在所有 Rerender 之间共享。对 count.current 赋值或读取，读到的永远是其最新值，而与渲染闭包无关 3.useEffect12345678910111213141516171819202122232425function Counter() &#123; const [count, setCount] = useState(0); const currentCount = useRef(count); useEffect(() =&gt; &#123; currentCount.current = count; &#125;); // 在每次渲染完毕后，将 count 此时最新的值赋给 currentCount.current，这样就使 currentCount 的值自动同步了 count 的最新值 const log = () =&gt; &#123; setCount(count + 1); setTimeout(() =&gt; &#123; console.log(currentCount.current); &#125;, 3000); &#125;; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;log&#125;&gt;Click me&lt;/button&gt; &lt;/div&gt; );&#125;// 3 3 3 useEffect是处理副作用的，其执行时机在每次Render渲染完毕后。(每次渲染都会执行，只是实际在真实DOM操作完毕后？？) useEffect也随着每次渲染而不同的，同一个组件不同渲染之间，useEffect内闭包环境完全独立。对于本次的例子，useEffect 共执行了四次，经历了如下四次赋值最终变成3。 //0 1 2 3 setTimeout的例子，三次点击触发了四次渲染，但setTimeout分别生效在第1、2、3次渲染中，因此值是0 1 2。 useEffect的例子中，三次点击也触发了四次渲染，但useEffect分别生效在第1、2、3、4次渲染中，最终使currentCount的值变成3 自定义Hook包装useRef-简易自定义Hook 123456789function useCurrentValue(value) &#123; const ref = useRef(0); useEffect(() =&gt; &#123; ref.current = value; &#125;, [value]); // 仅当 value 的值变化了，再将其最新值同步给 ref.current return ref;&#125; useEffect的第二个参数：dependences定义了useEffect的依赖，在新的渲染中，只要所有依赖项的引用都不发生变化，useEffect就不会被执行，且当依赖项为[]时，useEffect仅在初始化执行一次，后续的Rerender永远也不会被执行。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js奇奇怪怪的函数整理（不定时更新）（转载+整理）]]></title>
    <url>%2F2019%2F04%2F13%2Fjs%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86%EF%BC%88%E4%B8%8D%E5%AE%9A%E6%97%B6%E6%9B%B4%E6%96%B0%EF%BC%89%EF%BC%88%E8%BD%AC%E8%BD%BD%2B%E6%95%B4%E7%90%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[刷题或者开发中总会看到别人用过很多看起来特别高大上的函数方法（可能是我水平不够），这篇文章用来整理每次遇到的js函数，不定时更新，文中已标注转载位置。 1.数组相关的函数1.1.some()和every()every()与some()方法都是JS中数组的迭代方法。some()是对数组中每一项运行给定函数，如果该函数对任一项返回true，则返回true。every()是对数组中每一项运行给定函数，如果该函数对每一项返回true,则返回true。some一直在找符合条件的值，一旦找到，则不会继续迭代下去。every从迭代开始，一旦有一个不符合条件，则不会继续迭代下去。 123456789var arr = [ 1, 2, 3, 4, 5, 6 ]; console.log( arr.some(( item, index, array )=&gt;&#123; console.log( 'item=' + item + ',index='+index+',array='+array ); return item &gt; 3; &#125;)); console.log( arr.every(( item, index, array )=&gt;&#123; console.log( 'item=' + item + ',index='+index+',array='+array ); return item &gt; 3; &#125;)); 运行结果转自：https://blog.csdn.net/zhangjing0320/article/details/80677129]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js从数组中的对象取出特定字段并生成新的数组]]></title>
    <url>%2F2019%2F04%2F12%2Fjs%E4%BB%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%8F%96%E5%87%BA%E7%89%B9%E5%AE%9A%E5%AD%97%E6%AE%B5%E5%B9%B6%E7%94%9F%E6%88%90%E6%96%B0%E7%9A%84%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718var arr = [ &#123; 'id': '1', 'name': 'img1', 'imgUrl': './img1.jpg', &#125;, &#123; 'id': '2', 'name: 'img2', 'imgUrl': './img2.jpg', &#125;, &#123; 'id': '3', 'name': 'img3', 'imgUrl': './img3.jpg', &#125;];arr.map(x =&gt; &#123;return x.imgUrl&#125;) // 生成数组]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决div中嵌套元素时，二者点击事件同时触发]]></title>
    <url>%2F2019%2F04%2F12%2F%E8%A7%A3%E5%86%B3div%E4%B8%AD%E5%B5%8C%E5%A5%97%E5%85%83%E7%B4%A0%E6%97%B6%EF%BC%8C%E4%BA%8C%E8%80%85%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%90%8C%E6%97%B6%E8%A7%A6%E5%8F%91%2F</url>
    <content type="text"><![CDATA[阻止JS冒泡事件~ 以Angualr为例： 12345&lt;div class="previewImg" (click)="closeImg()"&gt; &lt;img id="leftArrow" *ngIf="mid &gt; left" (click)="leftImg($event)" src="../../../assets/community/leftArrow@3x.png"/&gt; &lt;img id="pre" src="&#123;&#123;imageUrl&#125;&#125;"/&gt; &lt;img id="rightArrow" *ngIf="mid &lt; right" (click)="rightImg($event)" src="../../../assets/community/rightArrow@3x.png"/&gt;&lt;/div&gt; 点击left或right时同时会触发外层的closeImg()事件，此时需阻止JS的冒泡事件。 1234567891011closeImg() &#123; this.imageUrl = '';&#125;leftImg(e) &#123; alert('left!'); e.stopPropagation();&#125;rightImg(e) &#123; alert('right!') e.stopPropagation();&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓手机端网页，开启输入法时页面内容被压缩的解决方法]]></title>
    <url>%2F2019%2F04%2F12%2F%E5%AE%89%E5%8D%93%E6%89%8B%E6%9C%BA%E7%AB%AF%E7%BD%91%E9%A1%B5%EF%BC%8C%E5%BC%80%E5%90%AF%E8%BE%93%E5%85%A5%E6%B3%95%E6%97%B6%E9%A1%B5%E9%9D%A2%E5%86%85%E5%AE%B9%E8%A2%AB%E5%8E%8B%E7%BC%A9%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在安卓手机端的网页中，打开输入框会使页面的整体内容压缩（可能因为我使用了百分比的布局）而在iphone浏览网页时则不会出现这种问题。对于这种情况需要添加部分js代码来防止页面的压缩。 123456789var h1 = $('body').height();var h2 = $('#upMenu').height();var h3 = $('#main').height();$(window).resize(function() &#123; $('body').height(h1); $('#upMenu').height(h2); $('#main').height(h3); $('#main').css('top', h2);&#125;); 我的页面是由upmenu和main两部分构成。具体原理是当浏览器窗口大小发生变化时调用函数$(window).resize，让输入法打开后的页面的body高度等于输入法打开前的页面的body高度，其他页面中的元素根据其定位方式去设置height或top、margin-top等样式即可。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手机端网页图片之间出现白线的解决方法]]></title>
    <url>%2F2019%2F04%2F12%2F%E6%89%8B%E6%9C%BA%E7%AB%AF%E7%BD%91%E9%A1%B5%E5%9B%BE%E7%89%87%E4%B9%8B%E9%97%B4%E5%87%BA%E7%8E%B0%E7%99%BD%E7%BA%BF%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[我开发的实际情况是一个纵向的图片的列表，每个img由div包裹，在手机段访问是图片之间会出现一条白线。原因是：img默认是内联模块，需要将其设置为display: block;当然div之间也不要有margin~ 如图为修改后的情况（修改前的情况找不到了(:з)∠)）]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
      </tags>
  </entry>
</search>
