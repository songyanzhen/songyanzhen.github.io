<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[自定义React Hooks]]></title>
    <url>%2F2020%2F06%2F24%2F%E8%87%AA%E5%AE%9A%E4%B9%89React%20Hooks%2F</url>
    <content type="text"><![CDATA[接上一篇笔记，了解常用自定义Hooks的写法，能够手写简单Hook。 后续有常用的hook会整理在这里。 参考文章：https://blog.csdn.net/KlausLily/article/details/104586371 1.自定义useState ？123456789101112131415161718192021222324import &#123; useEffect, useRef, useState &#125; from 'react' const useXState = (initState) =&gt; &#123; const [state, setState] = useState(initState) let isUpdate = useRef() // cb 回调赋值函数？ - callback const setXState = (state, cb) =&gt; &#123; setState(prev =&gt; &#123; isUpdate.current = cb // setState可能传值setCount(count+1)或者函数setCount(prevCount =&gt; prevCount+1)，返回新值 return typeof state === 'function' ? state(prev) : state &#125;) &#125; useEffect(() =&gt; &#123; if(isUpdate.current) &#123; // 手动调用回调赋值函数 isUpdate.current() &#125; &#125;) return [state, setXState] &#125; export default useXState 利用useRef的特性来作为标识区分是挂载还是更新，当执行setXstate时，会传入和setState一模一样的参数，并且将回调赋值给useRef的current属性，这样在更新完成时，我们手动调用current即可实现更新后的回调这一功能。迷惑：cb是哪来的？？？在日志中打印cb是个undefined？？？？ 2.useThrottle &amp; useDebounce12345678910111213141516171819202122232425262728293031323334353637// 节流function throttle(func, ms) &#123; let previous = 0; return function() &#123; let now = Date.now(); let context = this; let args = arguments; if (now - previous &gt; ms) &#123; func.apply(context, args); previous = now; &#125; &#125;&#125;// useThrottle 回调函数 时间间隔 依赖项数组const useThrottle = (fn, ms = 30, deps = []) =&gt; &#123; let previous = useRef(0) let [time, setTime] = useState(ms) useEffect(() =&gt; &#123; let now = Date.now(); if (now - previous.current &gt; time) &#123; fn(); previous.current = now; &#125; &#125;, deps) // 取消节流，可以忽略 const cancel = () =&gt; &#123; setTime(0) &#125;v return [cancel]&#125;// 节流setB，cancel为取消函数const [cancel] = useThrottle(() =&gt; &#123; setB(a) &#125;, 2000, [a]) 12345678910111213141516171819202122232425262728293031323334353637// 防抖function debounce(func, ms) &#123; let timeout; return function () &#123; let context = this; let args = arguments; if (timeout) clearTimeout(timeout); timeout = setTimeout(() =&gt; &#123; func.apply(context, args) &#125;, ms); &#125;&#125;// useDebounceconst useDebounce = (fn, ms = 30, deps = []) =&gt; &#123; let timeout = useRef() useEffect(() =&gt; &#123; if (timeout.current) clearTimeout(timeout.current) timeout.current = setTimeout(() =&gt; &#123; fn() &#125;, ms) &#125;, deps) const cancel = () =&gt; &#123; clearTimeout(timeout.current) timeout = null &#125; return [cancel]&#125;// 防抖setB，cancel为取消函数const [cancel] = useDebounce(() =&gt; &#123; setB(a) &#125;, 2000, [a]) n.useInitRender在当前参与开发的React-Native项目中，会有部分页面在刚进入时直接请求数据，会导致渲染和请求同步进行 =&gt; 部分机型上会卡顿，为了简化操作，自定义了一个简易的UseInitRender Hook。用来代替RN中进入页面即请求数据的useEffect。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950interface InitRenderProp &#123; request?: () =&gt; void; // 请求函数 action?: () =&gt; void; // 普通函数逻辑 willFocus?: () =&gt; void; // 监听函数（返回该页面时会调用，例如重新刷新数据） didFocus?: () =&gt; void; // 监听函数（返回该页面时会调用，例如重新刷新数据） navigation?: NavigationScreenProp&lt; // 用于添加监听 NavigationRoute&lt;NavigationParams&gt;, NavigationParams &gt;;&#125;export const useInitRender = (props: InitRenderProp): void =&gt; &#123; const &#123; request, action, willFocus, didFocus, navigation &#125; = props; useEffect((): void | (() =&gt; void) =&gt; &#123; if (request) &#123; // 期望首次render完成之后再请求数据 setTimeout((): void =&gt; &#123; request(); &#125;, 200); &#125; if (action) &#123; action(); &#125; let willFocusSubscription: NavigationEventSubscription | null = null; let didFocusSubscription: NavigationEventSubscription | null = null; if (willFocus &amp;&amp; navigation) &#123; willFocusSubscription = navigation.addListener('willFocus', (): void =&gt; willFocus() ); &#125; if (didFocus &amp;&amp; navigation) &#123; didFocusSubscription = navigation.addListener('didFocus', (): void =&gt; didFocus() ); &#125; return (): void =&gt; &#123; if (willFocusSubscription) &#123; willFocusSubscription.remove(); &#125; if (didFocusSubscription) &#123; didFocusSubscription.remove(); &#125; &#125;; &#125;, []);&#125;;]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Hooks记录]]></title>
    <url>%2F2020%2F06%2F22%2FReact%20Hooks%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[记录 React Hooks 学习情况，希望能通过记录的方式更深入地了解Hooks相关原理。主要内容来源： https://github.com/dt-fe/weekly/blob/v2/104.%E7%B2%BE%E8%AF%BB%E3%80%8AFunction%20Component%20%E5%85%A5%E9%97%A8%E3%80%8B.md Function Component 就是以 Function 的形式创建的 React 组件，Hooks 是辅助 Function Component 的工具。 1.useState12345678910111213141516171819function Counter() &#123; const [count, setCount] = useState(0); const log = () =&gt; &#123; setCount(count + 1); setTimeout(() =&gt; &#123; console.log(count); &#125;, 3000); &#125;; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;log&#125;&gt;Click me&lt;/button&gt; &lt;/div&gt; );&#125;// 0 1 2 state 是 Immutable 的（不可改变的） Class Component：通过 this.state 读取 state，会导致每次代码执行都会去拿最新的 state 引用 // 3 3 3 Function Component： 通过数组第二个参数 Set 一个新值后，原来的值会形成一个新的引用在下次渲染时。（感觉应该是当前渲染？或者是新的值会形成一个新的引用在下次渲染时？） 由于对 state 的读取没有通过 this.的方式，使得每次 setTimeout 都读取了当时渲染闭包环境的数据，虽然最新的值跟着最新的渲染变了，但旧的渲染里，状态依然是旧值。 共渲染四次（首次渲染+三次 setState，setTimeout 分别生效在 1、2、3 次渲染 → 对应 state 值 0、1、2） 12const [count, setCount] = useState(0);setCount(c =&gt; c + 1); // setCount的回调函数中，c值永远指向最新的count值 2.useRef12345678910111213141516171819function Counter() &#123; const count = useRef(0); const log = () =&gt; &#123; count.current++; setTimeout(() =&gt; &#123; console.log(count.current); &#125;, 3000); &#125;; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count.current&#125; times&lt;/p&gt; &lt;button onClick=&#123;log&#125;&gt;Click me&lt;/button&gt; &lt;/div&gt; );&#125;// 3 3 3 通过 useRef 创建的对象，其值只有一份，而且在所有 Rerender 之间共享。对 count.current 赋值或读取，读到的永远是其最新值，而与渲染闭包无关 3.useEffect12345678910111213141516171819202122232425function Counter() &#123; const [count, setCount] = useState(0); const currentCount = useRef(count); useEffect(() =&gt; &#123; currentCount.current = count; &#125;); // 在每次渲染完毕后，将 count 此时最新的值赋给 currentCount.current，这样就使 currentCount 的值自动同步了 count 的最新值 const log = () =&gt; &#123; setCount(count + 1); setTimeout(() =&gt; &#123; console.log(currentCount.current); &#125;, 3000); &#125;; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;log&#125;&gt;Click me&lt;/button&gt; &lt;/div&gt; );&#125;// 3 3 3 useEffect是处理副作用的，其执行时机在每次Render渲染完毕后。(每次渲染都会执行，只是实际在真实DOM操作完毕后？？) useEffect也随着每次渲染而不同的，同一个组件不同渲染之间，useEffect内闭包环境完全独立。对于本次的例子，useEffect 共执行了四次，经历了如下四次赋值最终变成3。 //0 1 2 3 setTimeout的例子，三次点击触发了四次渲染，但setTimeout分别生效在第1、2、3次渲染中，因此值是0 1 2。 useEffect的例子中，三次点击也触发了四次渲染，但useEffect分别生效在第1、2、3、4次渲染中，最终使currentCount的值变成3 自定义Hook包装useRef-简易自定义Hook 123456789function useCurrentValue(value) &#123; const ref = useRef(0); useEffect(() =&gt; &#123; ref.current = value; &#125;, [value]); // 仅当 value 的值变化了，再将其最新值同步给 ref.current return ref;&#125; useEffect的第二个参数：dependences定义了useEffect的依赖，在新的渲染中，只要所有依赖项的引用都不发生变化，useEffect就不会被执行，且当依赖项为[]时，useEffect仅在初始化执行一次，后续的Rerender永远也不会被执行。 将setTimeout换成setInterval 1234567891011121314function Counter() &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; const id = setInterval(() =&gt; &#123; setCount(count + 1); // setCount(0 + 1) setInterval永远在第一次Render的闭包中-count值永远为0 &#125;, 1000); return () =&gt; clearInterval(id); &#125;, []); // [count] - 1 2 3... return &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;;&#125;// 1 1 1 1 1 ... 依赖count却填了空 useEffect函数的返回值。它的返回值是一个函数，这个函数在useEffect即将重新执行时，会先执行上一次Rerender useEffect第一个回调的返回函数，再执行下一次渲染的useEffect第一个回调。如果useEffect 的第二个参数设置为了[]，那么其返回函数只会在这个组件被销毁时执行。 useEffect 对业务的抽象非常方便，几个例子： ·依赖项是查询参数，那么 useEffect 内可以进行取数请求，那么只要查询参数变化了，列表就会自动取数刷新。注意我们将取数时机从触发端改成了接收端。 ·当列表更新后，重新注册一遍拖拽响应事件。也是同理，依赖参数是列表，只要列表变化，拖拽响应就会重新初始化，这样我们可以放心的修改列表，而不用担心拖拽事件失效。 ·只要数据流某个数据变化，页面标题就同步修改。同理，也不需要在每次数据变化时修改标题，而是通过 useEffect “监听” 数据的变化，这是一种 “控制反转” 的思维。 4.useReducer123456789101112131415161718192021222324252627282930const [state, dispatch] = useReducer(reducer, initialState);// reducer 定义function reducer(state, action) &#123; switch (action.type) &#123; case "increment": return &#123; ...state, count: state.count + 1 &#125;; default: return state; &#125;&#125;// 可通过dispatch(&#123; type: 'increment' &#125;)实现state.count的自增function Counter() &#123; const [state, dispatch] = useReducer(reducer, initialState); const &#123; count &#125; = state; useEffect(() =&gt; &#123; const id = setInterval(() =&gt; &#123; dispatch(&#123; type: "increment" &#125;); &#125;, 1000); return () =&gt; clearInterval(id); &#125;, [dispatch]); // dispatch引用永远也不会变，只会执行一次 return &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;;&#125; 本质是让函数与数据解耦，函数只管发出指令，而不需要关心使用的数据被更新时，需要重新初始化自身。 5.useCallBack为了避免遗漏依赖，必须将函数写在useEffect内部 — 维护麻烦 — useCallBack 12345678910111213function Counter() &#123; const [count, setCount] = useState(0); const getFetchUrl = useCallback(() =&gt; &#123; return "https://v?query=" + count; &#125;, [count]); useEffect(() =&gt; &#123; getFetchUrl(); &#125;, [getFetchUrl]); return &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;;&#125; useCallback也有第二个参数-依赖项，我们将getFetchUrl函数的依赖项通过useCallback打包到新的getFetchUrl函数中，那么useEffect就只需要依赖getFetchUrl这个函数，就实现了对count的间接依赖。 将函数抽到组件外部 12345678910111213141516171819202122232425function useFetch(count, step) &#123; return useCallback(() =&gt; &#123; const url = "https://v/search?query=" + count + "&amp;step=" + step; &#125;, [count, step]);&#125;// 调用function Parent() &#123; const [count, setCount] = useState(0); const [step, setStep] = useState(0); const [other, setOther] = useState(0); const fetch = useFetch(count, step); // 封装了 useFetch useEffect(() =&gt; &#123; fetch(); &#125;, [fetch]); return ( &lt;div&gt; &lt;button onClick=&#123;() =&gt; setCount(c =&gt; c + 1)&#125;&gt;setCount &#123;count&#125;&lt;/button&gt; &lt;button onClick=&#123;() =&gt; setStep(c =&gt; c + 1)&#125;&gt;setStep &#123;step&#125;&lt;/button&gt; &lt;button onClick=&#123;() =&gt; setOther(c =&gt; c + 1)&#125;&gt;setOther &#123;other&#125;&lt;/button&gt; &lt;/div&gt; );&#125; 性能问题：count与step都会频繁变化，每次变化就会导致useFetch中useCallback依赖的变化，进而导致重新生成函数。然而实际上这种函数是没必要每次都重新生成的，反复生成函数会造成大量性能损耗。 1.利用Ref保证耗时函数依赖不变 -依赖不变，直接拿current，改动成本较高 1234567891011121314function useFetch(count, step) &#123; const countRef = useRef(count); const stepRef = useRef(step); useEffect(() =&gt; &#123; countRef.current = count; stepRef.current = step; &#125;); return useCallback(() =&gt; &#123; const url = "https://v/search?query=" + countRef.current + "&amp;step=" + stepRef.current; &#125;, [countRef, stepRef]); // 依赖不会变，却能每次拿到最新的值&#125; 2.通用的自定义Hooks解决函数重新实例化问题 可以利用useRef创造一个自定义Hook代替useCallback，使其依赖的值变化时，回调不会重新执行，却能拿到最新的值。 1234567891011121314function useEventCallback(fn, dependencies) &#123; const ref = useRef(null); // 当fn回调函数变化时，ref.current重新指向最新的fn这个逻辑中规中矩。重点是，当依赖dependencies变化时，也重新为ref.current赋值，此时fn内部的dependencies值是最新的 useEffect(() =&gt; &#123; ref.current = fn; &#125;, [fn, ...dependencies]); // 仅执行一次（ref引用不会改变），所以每次都可以返回dependencies是最新的fn，并且fn还不会重新执行 return useCallback(() =&gt; &#123; const fn = ref.current; return fn(); &#125;, [ref]);&#125; 假设我们对useEventCallback传入的回调函数称为X，则这段代码的含义，就是使每次渲染的闭包中，回调函数X拿到的总是最新Rerender闭包中的那个，所以依赖的值永远是最新的，而且函数不会重新初始化。 对于这种场景，也可以利用useReducer，将函数通过dispatch中调用（官方不推荐useEventCallback） 6.useMemo &amp;&amp; memoReact.memo等价于ClassComponent的PureComponent，使用memo包裹的组件，会在自身重渲染时，对每一个props项进行浅对比，如果引用没有变化，就不会触发重渲染。所以memo是一种很棒的性能优化工具。 123456789const Child = memo((props) =&gt; &#123; useEffect(() =&gt; &#123; props.fetchData() &#125;, [props.fetchData]) return ( // ... )&#125;) 用useMemo做局部PureRender - 更细粒度的优化渲染 123456789const Child = (props) =&gt; &#123; useEffect(() =&gt; &#123; props.fetchData() &#125;, [props.fetchData]) return useMemo(() =&gt; ( // ... ), [props.fetchData])&#125; 利用useMemo包裹渲染代码，这样即便函数Child因为props的变化重新执行了，只要渲染函数用到的props.fetchData没有变，就不会重新渲染 7.useContext单独组件可以通过useMemo来优化，当程序复杂时，可能存在多个函数在所有Function Component间共享的情况，此时需要使用新Hook：useContext 12345678910111213141516171819202122232425262728// 1.创建一个Contextconst Store = createContext(null);// 2.在根节点使用Store.Provider注入function Parent() &#123; const [count, setCount] = useState(0); const [step, setStep] = useState(0); const fetchData = useFetch(count, step); return ( &lt;Store.Provider value=&#123;&#123; setCount, setStep, fetchData &#125;&#125;&gt; &lt;Child /&gt; &lt;/Store.Provider&gt; );&#125;// 3.在子节点使用useContext拿到注入的数据（value）const Child = memo((props) =&gt; &#123; const &#123; setCount &#125; = useContext(Store) function onClick() &#123; setCount(count =&gt; count + 1) &#125; return ( // ... )&#125;) 这样就不需要在每个函数间进行参数透传了，公共函数可以都放在Context里。但是当函数多了，Provider的value会变得很臃肿，我们可以结合之前讲到的useReducer解决这个问题。 使用useReducer为Context传递内容瘦身 使用useReducer，所有回调函数都通过调用dispatch完成，那么Context只要传递dispatch一个函数就好了。子节点全部通过dispatch去改变全局的state。 12345678910111213141516171819202122232425const Store = createContext(null);function Parent() &#123; const [state, dispatch] = useReducer(reducer, &#123; count: 0, step: 0 &#125;); return ( &lt;Store.Provider value=&#123;dispatch&#125;&gt; &lt;Child /&gt; &lt;/Store.Provider&gt; );&#125;const Child = useMemo((props) =&gt; &#123; const dispatch = useContext(Store) function onClick() &#123; dispatch(&#123; type: 'countInc' &#125;) &#125; return ( // ... )&#125;) 将state也放到Context中 稍稍改造下，将state也放到Context中，这下赋值与取值都非常方便了！ 1234567891011121314151617181920212223242526272829303132333435const Store = createContext(null);function Parent() &#123; const [state, dispatch] = useReducer(reducer, &#123; count: 0, step: 0 &#125;); return ( &lt;Store.Provider value=&#123;&#123; state, dispatch &#125;&#125;&gt; &lt;Count /&gt; &lt;Step /&gt; &lt;/Store.Provider&gt; );&#125;// 不使用memo的原因：memo只能挡在最外层的，而通过useContext的数据注入发生在函数内部，会绕过memo，从而同时触发这两个组件的Rerenderconst Count = () =&gt; &#123; const &#123; state, dispatch &#125; = useContext(Store); return useMemo( () =&gt; ( &lt;button onClick=&#123;() =&gt; dispatch("incCount")&#125;&gt; incCount &#123;state.count&#125; &lt;/button&gt; ), [state.count, dispatch] );&#125;;const Step = () =&gt; &#123; const &#123; state, dispatch &#125; = useContext(Store); return useMemo( () =&gt; ( &lt;button onClick=&#123;() =&gt; dispatch("incStep")&#125;&gt;incStep &#123;state.step&#125;&lt;/button&gt; ), [state.step, dispatch] );&#125;; PS：当前开发的项目大致基于以上框架开发，并在此基础上用了一套action封装了所有需要使用的dispatch，可以在组件中直接调用action里的函数，直接改变state，防止出现重复的dispatch的情况 8.使用自定义Hook处理副作用比如上面抛出的异步取数场景，在Function Component的最佳做法是封装成一个自定义Hook： 1234567891011121314151617181920212223242526272829303132333435363738const useDataApi = (initialUrl, initialData) =&gt; &#123; const [url, setUrl] = useState(initialUrl); const [state, dispatch] = useReducer(dataFetchReducer, &#123; isLoading: false, isError: false, data: initialData &#125;); useEffect(() =&gt; &#123; let didCancel = false; const fetchData = async () =&gt; &#123; dispatch(&#123; type: "FETCH_INIT" &#125;); try &#123; const result = await axios(url); if (!didCancel) &#123; dispatch(&#123; type: "FETCH_SUCCESS", payload: result.data &#125;); &#125; &#125; catch (error) &#123; if (!didCancel) &#123; dispatch(&#123; type: "FETCH_FAILURE" &#125;); &#125; &#125; &#125;; fetchData(); return () =&gt; &#123; didCancel = true; &#125;; &#125;, [url]); const doFetch = url =&gt; setUrl(url); return &#123; ...state, doFetch &#125;;&#125;; 可以看到，自定义Hook拥有完整生命周期，我们可以将取数过程封装起来，只暴露状态-是否在加载中：isLoading，是否取数失败：isError，数据：data。使用情况如下，如果这个值需要存储到数据流，在所有组件之间共享，我们可以结合useEffect与useReducer： 12345678910111213141516function App(props) &#123; const &#123; dispatch &#125; = useContext(Store); const &#123; data, isLoading, isError &#125; = useDataApi("https://v", &#123; showLog: true &#125;); useEffect(() =&gt; &#123; dispatch(&#123; type: "updateLoading", data, isLoading, isError &#125;); &#125;, [dispatch, data, isLoading, isError]);&#125; 9.Others1.DefaultProps 对于 Function Component 的参数默认值，建议使用 React 内置方案解决，因为纯函数的方案不利于保持引用不变123456789101112const Child = (&#123; type &#125;) =&gt; &#123; useEffect(() =&gt; &#123; // 不断刷新父元素，只会打印出一次日志 console.log("type", type); &#125;, [type]); return &lt;div&gt;Child&lt;/div&gt;;&#125;;Child.defaultProps = &#123; type: &#123; a: 1 &#125;&#125;; 2.不要坑了子组件1234567891011121314151617181920function App() &#123; const [count, forceUpdate] = useState(0); const schema = &#123; b: 1 &#125;; return ( &lt;div&gt; &lt;Child schema=&#123;schema&#125; /&gt; &lt;div onClick=&#123;() =&gt; forceUpdate(count + 1)&#125;&gt;Count &#123;count&#125;&lt;/div&gt; &lt;/div&gt; );&#125;const Child = memo(props =&gt; &#123; useEffect(() =&gt; &#123; console.log("schema", props.schema); &#125;, [props.schema]); return &lt;div&gt;Child&lt;/div&gt;;&#125;); 只要父级props.schema变化就会打印日志。结果自然是，父组件每次刷新，子组件都会打印日志，也就是子组件[props.schema]完全失效了，因为引用一直在变化。 解法1：12345678const Child = memo(props =&gt; &#123; useEffect(() =&gt; &#123; console.log("schema", props.schema); // 子组件只关心值得变化 &#125;, [JSON.stringify(props.schema)]); return &lt;div&gt;Child&lt;/div&gt;;&#125;); 解法2：123456789101112function App() &#123; const [count, forceUpdate] = useState(0); // 利用Ref优化父组件 - 唯一引用 const schema = useRef(&#123; b: 1 &#125;); return ( &lt;div&gt; &lt;Child schema=&#123;schema.current&#125; /&gt; &lt;div onClick=&#123;() =&gt; forceUpdate(count + 1)&#125;&gt;Count &#123;count&#125;&lt;/div&gt; &lt;/div&gt; );&#125; 10.Conclusion以上是在重读（第n遍）这篇文章时做的记录，内容与文章可能没有太大出入，主要是想通过笔记的方式深入理解一哈Hooks，这一次阅读也了解了当前项目相关的Hook机制。对于自定义Hook方面还不是特别了解（至少感觉自己手写写不粗来），会在下一篇笔记中记录常用的自定义Hook的实现~]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序navigateTo传参被截断]]></title>
    <url>%2F2019%2F06%2F30%2F%E5%B0%8F%E7%A8%8B%E5%BA%8FnavigateTo%E4%BC%A0%E5%8F%82%E8%A2%AB%E6%88%AA%E6%96%AD%2F</url>
    <content type="text"><![CDATA[背景：最近在开发公司的小程序项目，为了方便采用了直接嵌入webview的方式开发，其中支付流程需要从webview跳转到小程序内完成。h5调用下单接口后会通过wx.miniProgram.navigateTo跳转到小程序页面进行支付操作。此时会以query的方式携带大量的参数，而直接将这些参数传递的话，会在小程序的onLoad里发现query被截断了。 解决方法：需要将参数进行编码后再传递。似乎其他通过query传参的场景也适用。 123456789h5：wx.navigateTo(&#123; url: '/pages/pay/index?payData=' + encodeURIComponent(payData)&#125;);小程序：onLoad: function (query) &#123; var url = decodeURIComponent(query.payData);&#125;]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>前端踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js奇奇怪怪的函数整理（不定时更新）（转载+整理）]]></title>
    <url>%2F2019%2F04%2F13%2Fjs%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86%EF%BC%88%E4%B8%8D%E5%AE%9A%E6%97%B6%E6%9B%B4%E6%96%B0%EF%BC%89%EF%BC%88%E8%BD%AC%E8%BD%BD%2B%E6%95%B4%E7%90%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[刷题或者开发中总会看到别人用过很多看起来特别高大上的函数方法（可能是我水平不够），这篇文章用来整理每次遇到的js函数，不定时更新，文中已标注转载位置。 1.数组相关的函数1.1.some()和every()every()与some()方法都是JS中数组的迭代方法。some()是对数组中每一项运行给定函数，如果该函数对任一项返回true，则返回true。every()是对数组中每一项运行给定函数，如果该函数对每一项返回true,则返回true。some一直在找符合条件的值，一旦找到，则不会继续迭代下去。every从迭代开始，一旦有一个不符合条件，则不会继续迭代下去。 123456789var arr = [ 1, 2, 3, 4, 5, 6 ]; console.log( arr.some(( item, index, array )=&gt;&#123; console.log( 'item=' + item + ',index='+index+',array='+array ); return item &gt; 3; &#125;)); console.log( arr.every(( item, index, array )=&gt;&#123; console.log( 'item=' + item + ',index='+index+',array='+array ); return item &gt; 3; &#125;)); 运行结果转自：https://blog.csdn.net/zhangjing0320/article/details/80677129]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js从数组中的对象取出特定字段并生成新的数组]]></title>
    <url>%2F2019%2F04%2F12%2Fjs%E4%BB%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%8F%96%E5%87%BA%E7%89%B9%E5%AE%9A%E5%AD%97%E6%AE%B5%E5%B9%B6%E7%94%9F%E6%88%90%E6%96%B0%E7%9A%84%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718var arr = [ &#123; 'id': '1', 'name': 'img1', 'imgUrl': './img1.jpg', &#125;, &#123; 'id': '2', 'name: 'img2', 'imgUrl': './img2.jpg', &#125;, &#123; 'id': '3', 'name': 'img3', 'imgUrl': './img3.jpg', &#125;];arr.map(x =&gt; &#123;return x.imgUrl&#125;) // 生成数组]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决div中嵌套元素时，二者点击事件同时触发]]></title>
    <url>%2F2019%2F04%2F12%2F%E8%A7%A3%E5%86%B3div%E4%B8%AD%E5%B5%8C%E5%A5%97%E5%85%83%E7%B4%A0%E6%97%B6%EF%BC%8C%E4%BA%8C%E8%80%85%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%90%8C%E6%97%B6%E8%A7%A6%E5%8F%91%2F</url>
    <content type="text"><![CDATA[阻止JS冒泡事件~ 以Angualr为例： 12345&lt;div class="previewImg" (click)="closeImg()"&gt; &lt;img id="leftArrow" *ngIf="mid &gt; left" (click)="leftImg($event)" src="../../../assets/community/leftArrow@3x.png"/&gt; &lt;img id="pre" src="&#123;&#123;imageUrl&#125;&#125;"/&gt; &lt;img id="rightArrow" *ngIf="mid &lt; right" (click)="rightImg($event)" src="../../../assets/community/rightArrow@3x.png"/&gt;&lt;/div&gt; 点击left或right时同时会触发外层的closeImg()事件，此时需阻止JS的冒泡事件。 1234567891011closeImg() &#123; this.imageUrl = '';&#125;leftImg(e) &#123; alert('left!'); e.stopPropagation();&#125;rightImg(e) &#123; alert('right!') e.stopPropagation();&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓手机端网页，开启输入法时页面内容被压缩的解决方法]]></title>
    <url>%2F2019%2F04%2F12%2F%E5%AE%89%E5%8D%93%E6%89%8B%E6%9C%BA%E7%AB%AF%E7%BD%91%E9%A1%B5%EF%BC%8C%E5%BC%80%E5%90%AF%E8%BE%93%E5%85%A5%E6%B3%95%E6%97%B6%E9%A1%B5%E9%9D%A2%E5%86%85%E5%AE%B9%E8%A2%AB%E5%8E%8B%E7%BC%A9%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在安卓手机端的网页中，打开输入框会使页面的整体内容压缩（可能因为我使用了百分比的布局）而在iphone浏览网页时则不会出现这种问题。对于这种情况需要添加部分js代码来防止页面的压缩。 123456789var h1 = $('body').height();var h2 = $('#upMenu').height();var h3 = $('#main').height();$(window).resize(function() &#123; $('body').height(h1); $('#upMenu').height(h2); $('#main').height(h3); $('#main').css('top', h2);&#125;); 我的页面是由upmenu和main两部分构成。具体原理是当浏览器窗口大小发生变化时调用函数$(window).resize，让输入法打开后的页面的body高度等于输入法打开前的页面的body高度，其他页面中的元素根据其定位方式去设置height或top、margin-top等样式即可。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手机端网页图片之间出现白线的解决方法]]></title>
    <url>%2F2019%2F04%2F12%2F%E6%89%8B%E6%9C%BA%E7%AB%AF%E7%BD%91%E9%A1%B5%E5%9B%BE%E7%89%87%E4%B9%8B%E9%97%B4%E5%87%BA%E7%8E%B0%E7%99%BD%E7%BA%BF%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[我开发的实际情况是一个纵向的图片的列表，每个img由div包裹，在手机段访问是图片之间会出现一条白线。原因是：img默认是内联模块，需要将其设置为display: block;当然div之间也不要有margin~ 如图为修改后的情况（修改前的情况找不到了(:з)∠)）]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端基础</tag>
      </tags>
  </entry>
</search>
