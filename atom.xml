<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>乐观的阿珍</title>
  
  <subtitle>song_yz@buaa.edu.cn</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-22T07:47:20.017Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Hain Song</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React Hooks记录</title>
    <link href="http://yoursite.com/2020/06/17/React%20Hooks%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/06/17/React Hooks记录/</id>
    <published>2020-06-17T02:50:03.000Z</published>
    <updated>2020-06-22T07:47:20.017Z</updated>
    
    <content type="html"><![CDATA[<p>记录 React Hooks 学习情况，希望能通过记录的方式更深入地了解Hooks相关原理。主要内容来源：</p><p><a href="https://github.com/dt-fe/weekly/blob/v2/104.%E7%B2%BE%E8%AF%BB%E3%80%8AFunction%20Component%20%E5%85%A5%E9%97%A8%E3%80%8B.md" target="_blank" rel="noopener">https://github.com/dt-fe/weekly/blob/v2/104.%E7%B2%BE%E8%AF%BB%E3%80%8AFunction%20Component%20%E5%85%A5%E9%97%A8%E3%80%8B.md</a></p><p>Function Component 就是以 Function 的形式创建的 React 组件，Hooks 是辅助 Function Component 的工具。</p><a id="more"></a><h2 id="1-useState"><a href="#1-useState" class="headerlink" title="1.useState"></a>1.useState</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> log = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setCount(count + <span class="number">1</span>);</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(count);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;log&#125;&gt;Click me&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 0 1 2</span></span><br></pre></td></tr></table></figure><p>state 是 Immutable 的（不可改变的）</p><p>Class Component：通过 this.state 读取 state，会导致每次代码执行都会去拿最新的 state 引用  // 3 3 3</p><p>Function Component：</p><p>通过数组第二个参数 Set 一个新值后，原来的值会形成一个新的引用在下次渲染时。<strong>（感觉应该是当前渲染？或者是新的值会形成一个新的引用在下次渲染时？）</strong></p><p>由于对 state 的读取没有通过 this.的方式，使得每次 setTimeout 都读取了当时渲染闭包环境的数据，虽然最新的值跟着最新的渲染变了，但旧的渲染里，状态依然是旧值。</p><p>共渲染四次（首次渲染+三次 setState，setTimeout 分别生效在 1、2、3 次渲染 → 对应 state 值 0、1、2）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">setCount(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>); <span class="comment">// setCount的回调函数中，c值永远指向最新的count值</span></span><br></pre></td></tr></table></figure><h2 id="2-useRef"><a href="#2-useRef" class="headerlink" title="2.useRef"></a>2.useRef</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> count = useRef(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> log = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    count.current++;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(count.current);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count.current&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;log&#125;&gt;Click me&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 3 3 3</span></span><br></pre></td></tr></table></figure><p><strong>通过 useRef 创建的对象，其值只有一份，而且在所有 Rerender 之间共享。</strong>对 count.current 赋值或读取，读到的永远是其最新值，而与渲染闭包无关</p><h2 id="3-useEffect"><a href="#3-useEffect" class="headerlink" title="3.useEffect"></a>3.useEffect</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> currentCount = useRef(count);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    currentCount.current = count;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 在每次渲染完毕后，将 count 此时最新的值赋给 currentCount.current，这样就使 currentCount 的值自动同步了 count 的最新值</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> log = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setCount(count + <span class="number">1</span>);</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(currentCount.current);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;log&#125;&gt;Click me&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 3 3 3</span></span><br></pre></td></tr></table></figure><p>useEffect是处理副作用的，其执行时机在每次Render渲染完毕后。(每次渲染都会执行，只是实际在真实DOM操作完毕后？？)</p><p>useEffect也随着每次渲染而不同的，同一个组件不同渲染之间，useEffect内闭包环境完全独立。对于本次的例子，useEffect 共执行了四次，经历了如下四次赋值最终变成3。 //0 1 2 3</p><p><strong>setTimeout的例子，三次点击触发了四次渲染，但setTimeout分别生效在第1、2、3次渲染中，因此值是0 1 2。</strong></p><p><strong>useEffect的例子中，三次点击也触发了四次渲染，但useEffect分别生效在第1、2、3、4次渲染中，最终使currentCount的值变成3</strong></p><p><em>自定义Hook包装useRef-简易自定义Hook</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useCurrentValue</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ref = useRef(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ref.current = value;</span><br><span class="line">  &#125;, [value]);</span><br><span class="line">  <span class="comment">// 仅当 value 的值变化了，再将其最新值同步给 ref.current</span></span><br><span class="line">  <span class="keyword">return</span> ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>useEffect的第二个参数：dependences定义了useEffect的依赖，在新的渲染中，只要所有依赖项的引用都不发生变化，useEffect就不会被执行，且当依赖项为[]时，useEffect仅在初始化执行一次，后续的Rerender永远也不会被执行。</p><p><em>将setTimeout换成setInterval</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setCount(count + <span class="number">1</span>); <span class="comment">// setCount(0 + 1) setInterval永远在第一次Render的闭包中-count值永远为0</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(id);</span><br><span class="line">  &#125;, []); <span class="comment">// [count] - 1 2 3...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 1 1 1 1 ... 依赖count却填了空</span></span><br></pre></td></tr></table></figure><p>useEffect函数的返回值。它的返回值是一个函数，这个函数在useEffect即将重新执行时，会先执行上一次Rerender useEffect第一个回调的返回函数，再执行下一次渲染的useEffect第一个回调。如果useEffect 的第二个参数设置为了[]，那么其返回函数只会在这个组件被销毁时执行。</p><p>useEffect 对业务的抽象非常方便，几个例子：</p><p>·依赖项是查询参数，那么 useEffect 内可以进行取数请求，那么只要查询参数变化了，列表就会自动取数刷新。注意我们将取数时机从触发端改成了接收端。</p><p>·当列表更新后，重新注册一遍拖拽响应事件。也是同理，依赖参数是列表，只要列表变化，拖拽响应就会重新初始化，这样我们可以放心的修改列表，而不用担心拖拽事件失效。</p><p>·只要数据流某个数据变化，页面标题就同步修改。同理，也不需要在每次数据变化时修改标题，而是通过 useEffect “监听” 数据的变化，这是一种 “控制反转” 的思维。</p><h2 id="4-useReducer"><a href="#4-useReducer" class="headerlink" title="4.useReducer"></a>4.useReducer</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialState);</span><br><span class="line"></span><br><span class="line"><span class="comment">// reducer 定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"increment"</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        count: state.count + <span class="number">1</span></span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可通过dispatch(&#123; type: 'increment' &#125;)实现state.count的自增</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialState);</span><br><span class="line">  <span class="keyword">const</span> &#123; count &#125; = state;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      dispatch(&#123; <span class="attr">type</span>: <span class="string">"increment"</span> &#125;);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(id);</span><br><span class="line">  &#125;, [dispatch]);</span><br><span class="line">  <span class="comment">// dispatch引用永远也不会变，只会执行一次</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质是让函数与数据解耦，函数只管发出指令，而不需要关心使用的数据被更新时，需要重新初始化自身。</p><h2 id="4-useCallBack"><a href="#4-useCallBack" class="headerlink" title="4.useCallBack"></a>4.useCallBack</h2><p>为了避免遗漏依赖，必须将函数写在useEffect内部 — 维护麻烦 — useCallBack</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> getFetchUrl = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"https://v?query="</span> + count;</span><br><span class="line">  &#125;, [count]);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    getFetchUrl();</span><br><span class="line">  &#125;, [getFetchUrl]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>useCallback也有第二个参数-依赖项，我们将getFetchUrl函数的依赖项通过useCallback打包到新的getFetchUrl函数中，那么useEffect就只需要依赖getFetchUrl这个函数，就实现了对count的间接依赖。</p><p><em>将函数抽到组件外部</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useFetch</span>(<span class="params">count, step</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">"https://v/search?query="</span> + count + <span class="string">"&amp;step="</span> + step;</span><br><span class="line">  &#125;, [count, step]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [step, setStep] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [other, setOther] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> fetch = useFetch(count, step); <span class="comment">// 封装了 useFetch</span></span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    fetch();</span><br><span class="line">  &#125;, [fetch]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>)&#125;&gt;setCount &#123;count&#125;&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setStep(c =&gt; c + 1)&#125;&gt;setStep &#123;step&#125;&lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setOther(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>)&#125;&gt;setOther &#123;other&#125;&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>性能问题</strong>：count与step都会频繁变化，每次变化就会导致useFetch中useCallback依赖的变化，进而导致重新生成函数。然而实际上这种函数是没必要每次都重新生成的，反复生成函数会造成大量性能损耗。</p><p><em>1.利用Ref保证耗时函数依赖不变</em> -依赖不变，直接拿current，改动成本较高</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useFetch</span>(<span class="params">count, step</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> countRef = useRef(count);</span><br><span class="line">  <span class="keyword">const</span> stepRef = useRef(step);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    countRef.current = count;</span><br><span class="line">    stepRef.current = step;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> url =</span><br><span class="line">      <span class="string">"https://v/search?query="</span> + countRef.current + <span class="string">"&amp;step="</span> + stepRef.current;</span><br><span class="line">  &#125;, [countRef, stepRef]); <span class="comment">// 依赖不会变，却能每次拿到最新的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>2.通用的自定义Hooks解决函数重新实例化问题</em></p><p>可以利用useRef创造一个自定义Hook代替useCallback，使其依赖的值变化时，回调不会重新执行，却能拿到最新的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useEventCallback</span>(<span class="params">fn, dependencies</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ref = useRef(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当fn回调函数变化时，ref.current重新指向最新的fn这个逻辑中规中矩。重点是，当依赖dependencies变化时，也重新为ref.current赋值，此时fn内部的dependencies值是最新的</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ref.current = fn;</span><br><span class="line">  &#125;, [fn, ...dependencies]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 仅执行一次（ref引用不会改变），所以每次都可以返回dependencies是最新的fn，并且fn还不会重新执行</span></span><br><span class="line">  <span class="keyword">return</span> useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fn = ref.current;</span><br><span class="line">    <span class="keyword">return</span> fn();</span><br><span class="line">  &#125;, [ref]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>假设我们对useEventCallback传入的回调函数称为X，则这段代码的含义，就是使每次渲染的闭包中，回调函数X拿到的总是最新Rerender闭包中的那个，所以依赖的值永远是最新的，而且函数不会重新初始化。</strong></p><p>对于这种场景，也可以利用useReducer，将函数通过dispatch中调用（官方不推荐useEventCallback）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录 React Hooks 学习情况，希望能通过记录的方式更深入地了解Hooks相关原理。主要内容来源：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dt-fe/weekly/blob/v2/104.%E7%B2%BE%E8%AF%BB%E3%80%8AFunction%20Component%20%E5%85%A5%E9%97%A8%E3%80%8B.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/dt-fe/weekly/blob/v2/104.%E7%B2%BE%E8%AF%BB%E3%80%8AFunction%20Component%20%E5%85%A5%E9%97%A8%E3%80%8B.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Function Component 就是以 Function 的形式创建的 React 组件，Hooks 是辅助 Function Component 的工具。&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="http://yoursite.com/categories/React/"/>
    
    
      <category term="前端基础" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>js奇奇怪怪的函数整理（不定时更新）（转载+整理）</title>
    <link href="http://yoursite.com/2019/04/13/js%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86%EF%BC%88%E4%B8%8D%E5%AE%9A%E6%97%B6%E6%9B%B4%E6%96%B0%EF%BC%89%EF%BC%88%E8%BD%AC%E8%BD%BD+%E6%95%B4%E7%90%86%EF%BC%89/"/>
    <id>http://yoursite.com/2019/04/13/js奇奇怪怪的函数整理（不定时更新）（转载+整理）/</id>
    <published>2019-04-13T03:54:55.000Z</published>
    <updated>2019-04-13T04:05:21.124Z</updated>
    
    <content type="html"><![CDATA[<p>刷题或者开发中总会看到别人用过很多看起来特别高大上的函数方法（可能是我水平不够），这篇文章用来整理每次遇到的js函数，不定时更新，文中已标注转载位置。<br><a id="more"></a></p><h2 id="1-数组相关的函数"><a href="#1-数组相关的函数" class="headerlink" title="1.数组相关的函数"></a>1.数组相关的函数</h2><h3 id="1-1-some-和every"><a href="#1-1-some-和every" class="headerlink" title="1.1.some()和every()"></a>1.1.some()和every()</h3><p>every()与some()方法都是JS中数组的迭代方法。<br>some()是对数组中每一项运行给定函数，如果该函数对任一项返回true，则返回true。<br>every()是对数组中每一项运行给定函数，如果该函数对每一项返回true,则返回true。<br>some一直在找符合条件的值，一旦找到，则不会继续迭代下去。<br>every从迭代开始，一旦有一个不符合条件，则不会继续迭代下去。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ]; </span><br><span class="line"><span class="built_in">console</span>.log( arr.some(<span class="function">(<span class="params"> item, index, array </span>)=&gt;</span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'item='</span> + item + <span class="string">',index='</span>+index+<span class="string">',array='</span>+array ); </span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">3</span>; </span><br><span class="line">&#125;)); </span><br><span class="line"><span class="built_in">console</span>.log( arr.every(<span class="function">(<span class="params"> item, index, array </span>)=&gt;</span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'item='</span> + item + <span class="string">',index='</span>+index+<span class="string">',array='</span>+array ); </span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">3</span>; </span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="/2019/04/13/js奇奇怪怪的函数整理（不定时更新）（转载+整理）/some&amp;every.png" alt="some&amp;every"><br>转自：<a href="https://blog.csdn.net/zhangjing0320/article/details/80677129" target="_blank" rel="noopener">https://blog.csdn.net/zhangjing0320/article/details/80677129</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题或者开发中总会看到别人用过很多看起来特别高大上的函数方法（可能是我水平不够），这篇文章用来整理每次遇到的js函数，不定时更新，文中已标注转载位置。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="前端基础" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>js从数组中的对象取出特定字段并生成新的数组</title>
    <link href="http://yoursite.com/2019/04/12/js%E4%BB%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%8F%96%E5%87%BA%E7%89%B9%E5%AE%9A%E5%AD%97%E6%AE%B5%E5%B9%B6%E7%94%9F%E6%88%90%E6%96%B0%E7%9A%84%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2019/04/12/js从数组中的对象取出特定字段并生成新的数组/</id>
    <published>2019-04-12T12:58:09.000Z</published>
    <updated>2019-04-12T13:02:21.793Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">'id'</span>: <span class="string">'1'</span>,</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'img1'</span>,</span><br><span class="line">    <span class="string">'imgUrl'</span>: <span class="string">'./img1.jpg'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">'id'</span>: <span class="string">'2'</span>,</span><br><span class="line">    <span class="string">'name: '</span>img2<span class="string">',</span></span><br><span class="line"><span class="string">    '</span>imgUrl<span class="string">': '</span>./img2.jpg<span class="string">',</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  &#123;</span></span><br><span class="line"><span class="string">    '</span>id<span class="string">': '</span><span class="number">3</span><span class="string">',</span></span><br><span class="line"><span class="string">    '</span>name<span class="string">': '</span>img3<span class="string">',</span></span><br><span class="line"><span class="string">    '</span>imgUrl<span class="string">': '</span>./img3.jpg<span class="string">',</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">];</span></span><br><span class="line"><span class="string">arr.map(x =&gt; &#123;return x.imgUrl&#125;) // 生成数组</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span 
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="前端基础" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>解决div中嵌套元素时，二者点击事件同时触发</title>
    <link href="http://yoursite.com/2019/04/12/%E8%A7%A3%E5%86%B3div%E4%B8%AD%E5%B5%8C%E5%A5%97%E5%85%83%E7%B4%A0%E6%97%B6%EF%BC%8C%E4%BA%8C%E8%80%85%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%90%8C%E6%97%B6%E8%A7%A6%E5%8F%91/"/>
    <id>http://yoursite.com/2019/04/12/解决div中嵌套元素时，二者点击事件同时触发/</id>
    <published>2019-04-12T12:57:57.000Z</published>
    <updated>2019-04-12T13:01:29.627Z</updated>
    
    <content type="html"><![CDATA[<p>阻止JS冒泡事件~</p><p>以Angualr为例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"previewImg"</span> (<span class="attr">click</span>)=<span class="string">"closeImg()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">"leftArrow"</span> *<span class="attr">ngIf</span>=<span class="string">"mid &gt; left"</span> (<span class="attr">click</span>)=<span class="string">"leftImg($event)"</span> <span class="attr">src</span>=<span class="string">"../../../assets/community/leftArrow@3x.png"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">"pre"</span> <span class="attr">src</span>=<span class="string">"&#123;&#123;imageUrl&#125;&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">"rightArrow"</span> *<span class="attr">ngIf</span>=<span class="string">"mid &lt; right"</span> (<span class="attr">click</span>)=<span class="string">"rightImg($event)"</span> <span class="attr">src</span>=<span class="string">"../../../assets/community/rightArrow@3x.png"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>点击left或right时同时会触发外层的closeImg()事件，此时需阻止JS的冒泡事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">closeImg() &#123;</span><br><span class="line">    <span class="keyword">this</span>.imageUrl = <span class="string">''</span>;</span><br><span class="line">&#125;</span><br><span class="line">leftImg(e) &#123;</span><br><span class="line">    alert(<span class="string">'left!'</span>);</span><br><span class="line">    e.stopPropagation();</span><br><span class="line">&#125;</span><br><span class="line">rightImg(e) &#123;</span><br><span class="line">    alert(<span class="string">'right!'</span>)</span><br><span class="line">    e.stopPropagation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;阻止JS冒泡事件~&lt;/p&gt;
&lt;p&gt;以Angualr为例：&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;previewImg&quot;&lt;/span&gt; (&lt;span class=&quot;attr&quot;&gt;click&lt;/span&gt;)=&lt;span class=&quot;string&quot;&gt;&quot;closeImg()&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;img&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;leftArrow&quot;&lt;/span&gt; *&lt;span class=&quot;attr&quot;&gt;ngIf&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;mid &amp;gt; left&quot;&lt;/span&gt; (&lt;span class=&quot;attr&quot;&gt;click&lt;/span&gt;)=&lt;span class=&quot;string&quot;&gt;&quot;leftImg($event)&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;src&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;../../../assets/community/leftArrow@3x.png&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;img&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;pre&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;src&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;&amp;#123;&amp;#123;imageUrl&amp;#125;&amp;#125;&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;img&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;rightArrow&quot;&lt;/span&gt; *&lt;span class=&quot;attr&quot;&gt;ngIf&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;mid &amp;lt; right&quot;&lt;/span&gt; (&lt;span class=&quot;attr&quot;&gt;click&lt;/span&gt;)=&lt;span class=&quot;string&quot;&gt;&quot;rightImg($event)&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;src&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;../../../assets/community/rightArrow@3x.png&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="前端基础" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>安卓手机端网页，开启输入法时页面内容被压缩的解决方法</title>
    <link href="http://yoursite.com/2019/04/12/%E5%AE%89%E5%8D%93%E6%89%8B%E6%9C%BA%E7%AB%AF%E7%BD%91%E9%A1%B5%EF%BC%8C%E5%BC%80%E5%90%AF%E8%BE%93%E5%85%A5%E6%B3%95%E6%97%B6%E9%A1%B5%E9%9D%A2%E5%86%85%E5%AE%B9%E8%A2%AB%E5%8E%8B%E7%BC%A9%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/04/12/安卓手机端网页，开启输入法时页面内容被压缩的解决方法/</id>
    <published>2019-04-12T12:53:56.000Z</published>
    <updated>2019-04-12T12:56:37.267Z</updated>
    
    <content type="html"><![CDATA[<p>在安卓手机端的网页中，打开输入框会使页面的整体内容压缩（可能因为我使用了百分比的布局）<br>而在iphone浏览网页时则不会出现这种问题。<br>对于这种情况需要添加部分js代码来防止页面的压缩。<br><a id="more"></a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> h1 = $(<span class="string">'body'</span>).height();</span><br><span class="line"><span class="keyword">var</span> h2 = $(<span class="string">'#upMenu'</span>).height();</span><br><span class="line"><span class="keyword">var</span> h3 = $(<span class="string">'#main'</span>).height();</span><br><span class="line">$(<span class="built_in">window</span>).resize(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'body'</span>).height(h1);</span><br><span class="line">    $(<span class="string">'#upMenu'</span>).height(h2);</span><br><span class="line">    $(<span class="string">'#main'</span>).height(h3);</span><br><span class="line">    $(<span class="string">'#main'</span>).css(<span class="string">'top'</span>, h2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我的页面是由upmenu和main两部分构成。<br>具体原理是当浏览器窗口大小发生变化时调用函数$(window).resize，让输入法打开后的页面的body高度等于输入法打开前的页面的body高度，<br>其他页面中的元素根据其定位方式去设置height或top、margin-top等样式即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在安卓手机端的网页中，打开输入框会使页面的整体内容压缩（可能因为我使用了百分比的布局）&lt;br&gt;而在iphone浏览网页时则不会出现这种问题。&lt;br&gt;对于这种情况需要添加部分js代码来防止页面的压缩。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="前端基础" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>手机端网页图片之间出现白线的解决方法</title>
    <link href="http://yoursite.com/2019/04/12/%E6%89%8B%E6%9C%BA%E7%AB%AF%E7%BD%91%E9%A1%B5%E5%9B%BE%E7%89%87%E4%B9%8B%E9%97%B4%E5%87%BA%E7%8E%B0%E7%99%BD%E7%BA%BF%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/04/12/手机端网页图片之间出现白线的解决方法/</id>
    <published>2019-04-12T12:45:32.000Z</published>
    <updated>2019-04-12T12:52:50.502Z</updated>
    
    <content type="html"><![CDATA[<p>我开发的实际情况是一个纵向的图片的列表，每个img由div包裹，在手机段访问是图片之间会出现一条白线。<br>原因是：img默认是内联模块，需要将其设置为display: block;<br>当然div之间也不要有margin~<br><a id="more"></a><br> 如图为修改后的情况（修改前的情况找不到了<em>(:з)∠)</em>）</p><p> <img src="/2019/04/12/手机端网页图片之间出现白线的解决方法/imgBlock.png" alt="imgBlock"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我开发的实际情况是一个纵向的图片的列表，每个img由div包裹，在手机段访问是图片之间会出现一条白线。&lt;br&gt;原因是：img默认是内联模块，需要将其设置为display: block;&lt;br&gt;当然div之间也不要有margin~&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="前端基础" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
